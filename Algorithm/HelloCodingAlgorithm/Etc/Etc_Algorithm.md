# 트리

이진 탐색 트리(Binary Search Tree)
이진 탐색트리는 이진탐색이 정렬된 배열에 대해서만 쓸 수 있는 단점이있는데, 그것을 보안해서 한번에 사용할 수 있게 하기 위해 사용됩니다.

이진 탐색 트리는 아래의 그림처럼 생겼습니다.

![image](https://user-images.githubusercontent.com/60413291/109169472-310a0380-77c3-11eb-8bdf-18dec0372fcb.png)

모든 정점에 대해 왼쪽에는 더 작은 값을 가진 정점, 오른쪽에는 더 큰값을 가진 정점이 오게 됩니다.
위의 그림이 알파벳순으로 정렬된 이진 탐색 트리입니다.
이진 탐색트리에서 항목을 찾으려면 평균적으로 O(log n) 시간이 걸리고, 최악의 경우에 O(n) 시간이 걸립니다. 정렬된 배열에서는 최악의 경우도 O(log n)이 걸립니다. 따라서 빠르다는 것을 알 수 있습니다. 그러나 단점으로서는

1. 임의 접근(random access)를 할 수 없습니다.
2. 평균적인 성능이 트리가 얼마나 균형잡힌지에 따라 정해집니다. (즉, 한쪽으로 치우친 트리일시 성능이 좋지 않고 균형을 이루면 성능이 좋다는 것입니다.)

# 병렬 알고리즘

데이터가 엄청나게 많으면 어떻게 다뤄야 되는지에 대한 의문을 풀어주는 알고리즘 중 하나가 병렬 알고리즘(Parallel algorithm)입니다.
병렬 알고리즘은 컴퓨터의 여러개의 코어가 하나씩 일을 나눠서 다 같이 일을 하는 알고리즘입니다. 병렬 알고리즘은 설계하기 어렵습니다. 그리고 속도 향상이 선형적이지 않습니다. 간단하게 말하면, 한 개의 코어가 아니라 두 개, 세 개 이렇게 사용해도 2배, 3배 이렇게 증가하지는 않습니다. 코어를 나눠서 실행해도 결국 합치는 과정이 있고, 일을 적절히 분산시키기도 어렵기 떄문입니다.

병렬 알고리즘의 예시를 한번 들어보겠습니다.
맵리듀스 알고리즘(MapReduce algorithm)은 분산 알고리즘(병렬 알고리즘중 하나) 중의 하나입니다. 코어가 2, 4개 이런식으로 필요한게 아니라 수백 개의 코어가 필요할때 사용되는 분산 알고리즘(distributed alogorithm) 입니다. 이것이 사용되는곳은 아파치 하둡(Apache Hadoop, 빅데이터 사용시 자주 사용됨)이 있습니다.
MSSql, MySql에서 데이터베이스를 처리할때 수조, 수억개의 데이터를 처리하기는 사실 너무 힘듭니다. 그런데 하둡에서 맵리듀스를 사용하면 가능합니다.

맵 함수 + 리듀스 함수를 합친것으로 생각하면 되는데
맵 함수는 배열을 입력으로 받아서 모든 원소에 같이 적용하는것이고 리듀스 함수는 리스트 전체의 원소를 하나의 원소로 축소(reduce)하는 것입니다.

맵 함수가

|1|2|3|4|5| 에서 |6|7|8|9|10| 으로 5씩 증가시키는 역할을 한다고 쳤을때, 그것을 여러개의 컴퓨터등에 골고루 배분해서 적용하는 것이고

리듀스는 |1|2|3|4|5| 에서 하나의 원소로 축소 할때 모든 값을 더하는 리듀스 함수가 있다고 쳤을떄 1+2+3+4+5=15, 즉 15의 값 단 하나만 나오게 되는 것입니다. 이 과정을 여러개의 컴퓨터가 거치면 컴퓨터 한대가 1000분이 필요한것이 1분에 끝날 수도 있습니다.

# SHA 알고리즘

SHA(보안 해시 알고리즘, Secure Hash Algorithm)함수는 해시 알고리즘의 일종입니다.
SHA 함수는 문자열을 받아서 그 문자열에 대한 해시값을 반환합니다. 예를들어 Name => "709A23220F2C3D64D1E1D6D18C4D5280F8D82FCA" 이렇게 말이죠(해시테이블의 (Name, 1) 이와 같이 키와 값을 가지는데 긴글자 라고 생각하면 편합니다.) 이 함수는 파일명이 같은지, 패스워드값을 암호화 한다던지 할 수 있습니다. 그리고 SHA는 단방향 해시라서 문자열에서 해시값을 얻을 순 있지만, 해시값에서 문자열을 가지고 올 수 없어서 암호화하기 좋습니다.

SHA 알고리즘의 특성중 암호화 하기 좋은 이유를 설명드리겠습니다. 지역 민감적이지 않다는 점입니다. 이말은 두문자가 비슷(E.g Alpha, Alphb)할때도 완벽하게 다른값이 나옵니다. 
Alpha => b1a96dd646bccaa24cef7a3db22a6f995f05658f4f1c3272913e258c03e6fb24, Alphb => 919a15a8a3ea4f6e70c4813f9cbfd0fff4cab5c231555994c0ecf4bd0a229ddd 이렇게 다릅니다.
이렇게 만약 해커가 존재한다면 패스워드를 추측할 때 패스워드와 어느 정도 비슷한지 알 수 없기때문에 좋은 특성입니다.
다만, 지역 민감 해시(locality-sensitive hash)함수가 필요할 수 도 있습니다. 이때는 Simhash를 사용합니다. 이러면 두문자가 비슷하면 비슷한 값이 나옵니다. 이는 중복을 확인할때에 굉장히 유용하게 사용됩니다.

# 디피-헬만 알고리즘

디피-헬만 알고리즘(Diffie-Hellman algorithm)은 메세지를 받은 사람만 읽을 수 있도록 하기 위한 알고리즘입니다.
메세지를 받은 사람만 읽을 수 있도록 하기 위해서는 암호화를 해야할 필요가 있고, 그 메세지의 암호를 쉽게 풀 수 없어야 됩니다.

> 양쪽 모두 암호 해독 규칙을 가질필요가 없어야하고 그로인해 암호 해독 규칙을 공유할 필요가 없어야 합니다.
> 암호화된 메세지는 해독하기 어려워야 합니다.
 
디피-헬만 알고리즘은 두 개의 키를 가집니다. 하나는 공개 키(public key), 하나는 개인키(Primary key)입니다. 공개키는 말그대로 공개되고, 누구나 볼 수 있습니다. 다만 해독하기위해서는 개인키가 있어서 개인키로 해독해야 됩니다. 즉, 개인키가 있으면 메세지를 해독할 수 있다는 것 입니다.

# 선형 프로그래밍

선형 프로그래밍(linear programing)은 주어진 제한 조건 하에서 무언가를 최대화할때 사용됩니다.
예를 들면, 두꺼운배게와 얇은이불을 만드는데 배게에는 천 1m와 솜 1kg이 필요하고 가방을 만드는데는 천 2m와 솜 0.8kg이 필요하다고 가정하고 집에서는 천 20개, 솜 10kg 이 있고, 배게는 2달러, 이불은 3달러 라고 생각했을때 가장 비싸게 팔 수 있는 조건을 구한다. 이런것처럼 주어진 제한(천과 솜의 양, 각각 의 가격 등등...)으로 최대한의 이익을 가져오는 알고리즘입니다.
선형알고리즘은 굉장히 방대한 주제이고, 그래프 문제또한 선형알고리즘의 하나라고 생각하면 도빈디ㅏ.
선형 프로그래밍에서는 심플렉스 알고리즘(Simplex algortihm)을 사용합니다.
