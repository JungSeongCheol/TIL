# 탐욕 알고리즘(Greedy Algorithm)

그리디 알고리즘은 문제를 해결하는 과정에서 그때그때, 각각의 단계에서 최적의 수를 찾아가는 알고리즘 입니다.
예를 들면,
|강의 |시작 시간|종료 시간|
|------|-------|-------|
|C# |08:00 |09:00|
|Java |08:30|09:30|
|Python |09:00|10:00|
|JavaScript|09:30|10:30 |
|R |10:00|11:00 |

와 같은 시간이 있다고 쳤을때, 가장 강의를 많이 들을 수 있는 방법을 찾는 법은

1. 가장 빨리 끝나는 강의를 고른다.
2. 그 강의가 끝난 후에 시작하는 강의를 고르고, 마찬가지로 가장 빨리 끝나는 과목을 고른다. 이것을 반복한다.

이렇게 하면 C#, Python, R을 들었을때 가장 많은 강의를 들을 수 있습니다. 방금의 1,2의 방법이 그리디 알고리즘을 사용 한 방식입니다.
<br/>
그리디 알고리즘은 문제 해결기법중 하나입니다.
탐욕 알고리즘은 간단하다는 특징을 가지고 있습니다.

# 탐욕 알고리즘 예제(마트카트 채우기)

만약 전자제품 마트에서 마트카트에 들어간 모든 물건을 공짜로 주는 이벤트를 한다고 쳐봅시다.
카트안에는 최대 3.5kg을 가질 수 있습니다. 물건은
|물건 |가격|무게|
|------|-------|-------|
|TV     |200만원 |2.0kg|
|노트북 |150만원 |1.5kg|
|컴퓨터 |300만원 |3.0kg| 

이라고 쳤을때 TV와 노트북을 함께 사면 350만원이고, 컴퓨터를 사면 300만원의 이득으로 TV와 노트북을 샀을때 좀 더 많은 이득을 볼 수 있습니다.
그런데 그리디 알고리즘은 가장 비싼물건(300만원 짜리 컴퓨터)를 구매하게 됩니다.(각각의 단계에서 최적의 값을 찾아냄 -> 처음 가장 비싼 물건이 컴퓨터이므로)
그래서 물건은 가장 완벽한 해답은 아닙니다. 그러나, 정답에 상당히 가까운 가격입니다. 만약 이벤트의 기간이 곧 끝나서, 빠르게 물건을 구매 해야 한다면 이정도로 충분합니다.
그래서 그리디 알고리즘은
> 구현이 정확하지 않더라도, 정답에 가깝기만 하면 되고 구하는 시간이 빨라야 한다면 사용되는 알고리즘 입니다.

# 집합 커버링 문제

우리가 인터넷 쇼핑몰에서 과자를 사고 싶다고 쳐봅시다. 그런데 과자를 싸게 파는 종류가 다 다릅니다. 가장 싼것들을 모아서 표로 정리하면
|물건 |가격|
|------|-------|
|옥션 |새우깡, 포카칩, 초코파이|
|쿠팡 |바나나칩, 새우깡, 빅파이|
|11번가 |초코파이, 빅파이, 포테이토칩|
|위메프 |바나나칩, 새우깡, 감자깡, 프링글스|

이렇게 있다고 가정해 봅시다.
이 과자들을 사는데 가장 적은수의 쇼핑몰 집합은 어떻게 구해야 할지 정해봅시다.(이 문제는 생각보다 정확하게 구하기 어렵습니다.)
1. 가능한 모든 쇼핑몰의 부분 잡합을 나열해봅시다. 이것을 멱집합(power set)이라고 합니다. 가능한 부분 집합의 갯수는 2^n개 입니다.
(1번 부분집합 - 새우깡, 초코파이 ...) (2번 부분집합 - 바나나칩, 새우깡 ...) ... 계속 이런식으로

2. 이 부분 집합 중에 모든 쇼핑몽을 커버할 수 있으면서 가장 원소의 수가 적은 부분 집합을 고릅니다.

그런데 이렇게 하면 단점이 존재한다. log(n^2)이라는, 말도 안되는 빅오표기법 속도가 나오게된다.
따라서 이방법은 추천하지 않는다. (5~10개 이런식이면 괜찮지만 100개 , 1000개 이렇게 되버리면 속도가 말도안되게 늦기 때문입니다.)
<br/>
이럴때, 정확한 답은 아니지만 근사 알고리즘 중 하나인 탐욕알고리즘을 결정합니다.

1. 아직 쇼핑몰을 정하지 않는 곳들중 가장 많이 파는곳을 고릅니다. 이미 똑같은 물건이 일부 있더라도 상관없습니다.
2. 모든 과자가 선택될때 까지 반복합니다.

이방식을 근사 알고리즘(approximation algorithm) 이라고 합니다.

