# 탐욕 알고리즘(Greedy Algorithm)

그리디 알고리즘은 문제를 해결하는 과정에서 그때그때, 각각의 단계에서 최적의 수를 찾아가는 알고리즘 입니다.
예를 들면,
|강의 |시작 시간|종료 시간|
|------|-------|-------|
|C# |08:00 |09:00|
|Java |08:30|09:30|
|Python |09:00|10:00|
|JavaScript|09:30|10:30 |
|R |10:00|11:00 |

와 같은 시간이 있다고 쳤을때, 가장 강의를 많이 들을 수 있는 방법을 찾는 법은

1. 가장 빨리 끝나는 강의를 고른다.
2. 그 강의가 끝난 후에 시작하는 강의를 고르고, 마찬가지로 가장 빨리 끝나는 과목을 고른다. 이것을 반복한다.

이렇게 하면 C#, Python, R을 들었을때 가장 많은 강의를 들을 수 있습니다. 방금의 1,2의 방법이 그리디 알고리즘을 사용 한 방식입니다.
<br/>
그리디 알고리즘은 문제 해결기법중 하나입니다.
탐욕 알고리즘은 간단하다는 특징을 가지고 있습니다.

# 탐욕 알고리즘 예제(마트카트 채우기)

만약 전자제품 마트에서 마트카트에 들어간 모든 물건을 공짜로 주는 이벤트를 한다고 쳐봅시다.
카트안에는 최대 3.5kg을 가질 수 있습니다. 물건은
|물건 |가격|무게|
|------|-------|-------|
|TV     |200만원 |2.0kg|
|노트북 |150만원 |1.5kg|
|컴퓨터 |300만원 |3.0kg| 

이라고 쳤을때 TV와 노트북을 함께 사면 350만원이고, 컴퓨터를 사면 300만원의 이득으로 TV와 노트북을 샀을때 좀 더 많은 이득을 볼 수 있습니다.
그런데 그리디 알고리즘은 가장 비싼물건(300만원 짜리 컴퓨터)를 구매하게 됩니다.(각각의 단계에서 최적의 값을 찾아냄 -> 처음 가장 비싼 물건이 컴퓨터이므로)
그래서 물건은 가장 완벽한 해답은 아닙니다. 그러나, 정답에 상당히 가까운 가격입니다. 만약 이벤트의 기간이 곧 끝나서, 빠르게 물건을 구매 해야 한다면 이정도로 충분합니다.
그래서 그리디 알고리즘은
> 구현이 정확하지 않더라도, 정답에 가깝기만 하면 되고 구하는 시간이 빨라야 한다면 사용되는 알고리즘 입니다.

# 집합 커버링 문제

우리가 인터넷 쇼핑몰에서 과자를 사고 싶다고 쳐봅시다. 그런데 과자를 싸게 파는 종류가 다 다릅니다. 가장 싼것들을 모아서 표로 정리하면
|물건 |가격|
|------|-------|
|옥션 |새우깡, 포카칩, 초코파이|
|쿠팡 |바나나칩, 새우깡, 빅파이|
|11번가 |초코파이, 빅파이, 포테이토칩|
|위메프 |바나나칩, 새우깡, 감자깡, 프링글스|

이렇게 있다고 가정해 봅시다.
이 과자들을 사는데 가장 적은수의 쇼핑몰 집합은 어떻게 구해야 할지 정해봅시다.(이 문제는 생각보다 정확하게 구하기 어렵습니다.)
1. 가능한 모든 쇼핑몰의 부분 잡합을 나열해봅시다. 이것을 멱집합(power set)이라고 합니다. 가능한 부분 집합의 갯수는 2^n개 입니다.
(1번 부분집합 - 새우깡, 초코파이 ...) (2번 부분집합 - 바나나칩, 새우깡 ...) ... 계속 이런식으로

2. 이 부분 집합 중에 모든 쇼핑몽을 커버할 수 있으면서 가장 원소의 수가 적은 부분 집합을 고릅니다.

그런데 이렇게 하면 단점이 존재한다. log(n^2)이라는, 말도 안되는 빅오표기법 속도가 나오게된다.
따라서 이방법은 추천하지 않는다. (5~10개 이런식이면 괜찮지만 100개 , 1000개 이렇게 되버리면 속도가 말도안되게 늦기 때문입니다.)
<br/>
이럴때, 정확한 답은 아니지만 근사 알고리즘 중 하나인 탐욕알고리즘을 결정합니다.

1. 아직 쇼핑몰을 정하지 않는 곳들중 가장 많이 파는곳을 고릅니다. 이미 똑같은 물건이 일부 있더라도 상관없습니다.
2. 모든 과자가 선택될때 까지 반복합니다.

이방식을 근사 알고리즘(approximation algorithm) 이라고 합니다.

# NP-완전 문제

집합 커버링 문제(set-covering problem)를 풀기 위해서는 가능한 모든 집합을 계산해야됩니다.
1번, 2번 ... 5000번. 이런식으로 말이죠
외판원 문제를 생각하면 좀더 편합니다.(외판원이 서로다른 도시를 방문해야 될때 최단경로 문제)
단계별로 풀어 봅시다.

작은 것 부터 먼저 풀어봅시다.
도시가 2개만 존재한다고 생각했을떄, 선택할수 있는 경로는 2개입니다.
서울 > 부산, 부산 > 서울 이렇게 2가지 입니다.
(이 2가지 경로가 같지는 않습니다. 왜냐하면 서울에서 부산까지 가는데 직통이지만, 부산에서 서울까지 가는데 일방통행이 없을 수 도 있기 때문입니다.)
특정 도시가 정해지지 않을 경우를 생각해 보면, 도시가 두 개인 경우는 가능한 경로는 두개입니다.
<br/>
> 도시가 3 개 인경우
인천에서 출발할시
인천 > 서울 > 부산, 인천 > 부산 > 서울
서울 > 인천 > 부산, 서울 > 부산 > 인천
부산 > 인천 > 서울, 부산 > 서울 > 인천
이렇게 6가지의 경로가 존재하고, 각가의 도시에서 출발하는 방법은 2가지 입니다.
<br/>
> 도시가 4개인경우는 대구에서 출발한다고 쳤을때
1.대구 > 인천 > 서울 > 부산 2. 대구 > 인천 > 부산 > 서울 3. 대구 > 서울 > 인천 > 부산 4. 대구 > 서울 > 부산 > 인천 5. 대구 > 부산 > 서울 > 인천 6.대구 > 부산 > 인천 > 서울
이렇게 총 6개가 대구로 출발하는것이고 그게 인천, 부산, 서울까지 합해야 되므로 4 * 6 = 24개가 됩니다.
이렇게 계속 증가하면 n!로 계산할 수 있다는 것을 알 수 있습니다. 따라서 도시하나가 추가되면 엄청나게 많은 수가 존재하게 됩니다. 이러므로 도시의 수가 많은 경우 외판원 문제를 풀기 힘듭니다.
외판원 문제, 집합 커버링 문제 공통점이 모든 가능한 경우를 다 따지는 것이므로, 최단/최소를 구하는 것입니다. 이런 문제를 NP-완전 문제(NP-complete problem)이라고 합니다.
<br>
외판원 문제 근사 알고리즘(짧은 거리를 찾는 간단한 방법) - 간단하게 생각하면 아무 도시나 선택한후, 그중에 가장 가까운 도시를 선택하면 최적은 아니라도 비슷하게 나옵니다.

# NP-완전문제로 풀어야 하는 문제

1. 항목이 적을때는 알고리즘이 빠른데, 항목이 늘어나면 갑자기 느려짐.
2. X의 모든 조합(대부분)
3. 더 작은 하위문제 변환 불가능할때
4. 문제가 수열을 포함하고, 풀기가 어려움
5. 집합이 있고, 풀기가 어려우면 NP-완전문제
6. 문제를 집합 커버링 문제나 외판원 문제로 재정의 가능하면 반드시 NP-완전문제

6번을 제외한 나머지는, 대부분인 경우인 것이고, 반드시는 아닙니다.
