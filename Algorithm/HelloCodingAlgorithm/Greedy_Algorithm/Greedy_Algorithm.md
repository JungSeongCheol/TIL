# 탐욕 알고리즘(Greedy Algorithm)

그리디 알고리즘은 문제를 해결하는 과정에서 그때그때, 각각의 단계에서 최적의 수를 찾아가는 알고리즘 입니다.
예를 들면,
|강의 |시작 시간|종료 시간|
|------|-------|-------|
|C# |08:00 |09:00|
|Java |08:30|09:30|
|Python |09:00|10:00|
|JavaScript|09:30|10:30 |
|R |10:00|11:00 |
와 같은 시간이 있다고 쳤을때, 가장 강의를 많이 들을 수 있는 방법을 찾는 법은

1. 가장 빨리 끝나는 강의를 고른다.
2. 그 강의가 끝난 후에 시작하는 강의를 고르고, 마찬가지로 가장 빨리 끝나는 과목을 고른다. 이것을 반복한다.

이렇게 하면 C#, Python, R을 들었을때 가장 많은 강의를 들을 수 있습니다. 방금의 1,2의 방법이 그리디 알고리즘을 사용 한 방식입니다.
<br/>
그리디 알고리즘은 문제 해결기법중 하나입니다.
탐욕 알고리즘은 간단하다는 특징을 가지고 있습니다.

# 탐욕 알고리즘 예제(마트카트 채우기)

만약 전자제품 마트에서 마트카트에 들어간 모든 물건을 공짜로 주는 이벤트를 한다고 쳐봅시다.
카트안에는 최대 3.5kg을 가질 수 있습니다. 물건은
|물건 |가격|무게|
|------|-------|-------|
|TV     |200만원 |2.0kg|
|노트북 |150만원 |1.5kg|
|컴퓨터 |300만원 |3.0kg| 

이라고 쳤을때 TV와 노트북을 함께 사면 350만원이고, 컴퓨터를 사면 300만원의 이득으로 TV와 노트북을 샀을때 좀 더 많은 이득을 볼 수 있습니다.
그런데 그리디 알고리즘은 가장 비싼물건(300만원 짜리 컴퓨터)를 구매하게 됩니다.(각각의 단계에서 최적의 값을 찾아냄 -> 처음 가장 비싼 물건이 컴퓨터이므로)
그래서 물건은 가장 완벽한 해답은 아닙니다. 그러나, 정답에 상당히 가까운 가격입니다. 만약 이벤트의 기간이 곧 끝나서, 빠르게 물건을 구매 해야 한다면 이정도로 충분합니다.
그래서 그리디 알고리즘은
> 구현이 정확하지 않더라도, 정답에 가깝기만 하면 되고 구하는 시간이 빨라야 한다면 사용되는 알고리즘 입니다.

# 집합 커버링 문제

우리가 인터넷 쇼핑몰에서 과자를 사고 싶다고 쳐봅시다. 그런데 과자를 싸게 파는 종류가 다 다릅니다. 가장 싼것들을 모아서 표로 정리하면
|물건 |가격|
|------|-------|
|옥션 |새우깡, 포카칩, 초코파이|
|쿠팡 |바나나칩, 새우깡, 빅파이|
|11번가 |초코파이, 빅파이, 포테이토칩|

이렇게 있다고 가정해 봅시다.
